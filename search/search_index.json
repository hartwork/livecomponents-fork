{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Django Live Component is a library for creating dynamic web applications that handle user interactions with the DOM on the server side. It leverages Django, HTMX, and Alpine.js to provide a seamless experience for both developers and users.</p> <p>To get started, follow the quickstart guide</p> <p>Leaky Abstractions</p> <p>There is a concept known as leaky abstractions. This occurs when a software component's abstraction does not fully hide the implementation details of its underlying layers, causing them to \"leak through\" in non-trivial cases.</p> <p>In this sense, livecomponents are quite leaky. Think of it as a \"glue\" that helps you combine HTMX and Django with django-components without writing too much boilerplate code. However, be prepared to deal with implementation details when they surface in your application.</p>"},{"location":"component_ids/","title":"Component IDs","text":"<ul> <li>Every component must have a root element that includes its ID. The ID is <code>id={{ component_id }}</code>.</li> <li>Component IDs represent the component hierarchy and are formatted as \"|parent:id|child:id\". For example, we can have a component |form:0|button:submit where \"button\" is the component type, \"submit\" is its name, and \"form:0\" is its parent.</li> </ul> <p>In many contexts, you get access to the StateAddress object, which consists of the session ID and the component ID. In this pair, the component ID is a \"ComponentId\" instance (a subclass of str), which has a helpful method to create child items.</p> <p>It can be used like this, without explicitly setting the child own_id:</p> <pre><code>state_address.component_id | \"child_component\"\n</code></pre> <p>Or like this, with explicitly setting the child own_id:</p> <pre><code>state_address.component_id | (\"child_component\", \"child_own_id\")\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The application is configured with the \"LIVECOMPONENTS\" dictionary in the settings.py file. Here's the default settings:</p> <pre><code>LIVECOMPONENTS = {\n    \"state_serializer\": {\n        \"cls\": \"livecomponents.manager.serializers.PickleStateSerializer\",\n        \"config\": {},\n    },\n    \"state_store\": {\n        # You can also use \"MemoryStateStore\" for tests.\n        \"cls\": \"livecomponents.manager.stores.RedisStateStore\",\n        # See \"RedisStateStore\" constructor for config options.\n        \"config\": {},\n    },\n    \"state_manager\": {\n        \"cls\": \"livecomponents.manager.manager.StateManager\",\n        \"config\": {},\n    },\n    # Allow livecomponents views to be embedded in iframes.\n    # Default: False\n    \"xframe_options_exempt\": False,\n}\n</code></pre>"},{"location":"configuration/#security-considerations","title":"Security Considerations","text":""},{"location":"configuration/#x-frame-options-exemption","title":"X-Frame-Options Exemption","text":"<p>The <code>xframe_options_exempt</code> setting allows the livecomponents views to be embedded in iframes. This is safe to enable because:</p> <ol> <li>The views only accept POST requests, rejecting all GET requests with a 405 status code</li> <li>Any attempt to embed these views in an iframe will result in a GET request, which is rejected</li> <li>Even if a POST request is somehow made from an iframe, it would still require:</li> <li>A valid CSRF token</li> <li>A valid session ID</li> <li>Proper component registration</li> <li>Valid command parameters</li> </ol> <p>This makes the views inherently resistant to clickjacking attacks, as there's no way to trigger meaningful actions through iframe embedding.</p>"},{"location":"context/","title":"Storing Component Context","text":"<p>During the first render, components use the entire page context to render themselves.</p> <p>During subsequent renders, components by default use the context populated from their state.</p> <p>However, it is possible to save some variables from the context of the first render. To do this, pass the <code>save_context</code> variable with a comma-separated list of variables that need to be sent to the <code>livecomponent</code> templatetag.</p> <p>This approach is commonly used when working with live component slots.</p> <p>Let's first look at an example of a \"non-prepared\" component that will only work on the first render:</p> <pre><code>{% livecomponent_block \"alert\" %}\n  {% fill \"body\" %}Sending a message to {{ user.email }}!{% endfill %}\n{% endlivecomponent_block %}\n</code></pre> <p>This will not work on partial renders because the component will be rendered without the \"user\" variable.</p> <p>To address this, add the \"save_context\" variable:</p> <pre><code>-{% livecomponent_block \"alert\" %}\n+{% livecomponent_block \"alert\" save_context=\"user\" %}\n   {% fill \"body\" %}Sending a message to {{ user.email }}!{% endfill %}\n {% endlivecomponent_block %}\n</code></pre>"},{"location":"decorators/","title":"Decorators","text":"<p>LiveComponents provide a method decorator to ensure the user is authenticated.</p> <pre><code>from livecomponents import LiveComponent, InitStateContext, CallContext\nfrom livecomponents.decorators import livecomponents_login_required\n\n\nclass Something(LiveComponent):\n\n    @classmethod\n    @livecomponents_login_required\n    def init_state(cls, context: InitStateContext):\n        ...\n\n    @classmethod\n    @livecomponents_login_required\n    def do_something(cls, call_context: CallContext[SomethingState], **kwargs):\n        ...\n</code></pre>"},{"location":"error_handling/","title":"Error handling","text":"<p>The response to calling the command can be an HTTP error. If the command handler fails to find a session, it will return an HTTP 410 Gone error.</p> <p>You can handle this error on the client side. For example, here a JavaScript code snippet to reload the page on the error 410.</p> <pre><code>document.addEventListener(\"htmx:responseError\", function (event) {\n    const statusCode = event.detail.xhr.status;\n    if (statusCode === 410) {\n        document.location.reload();\n    }\n});\n</code></pre> <p>If you use hyperscript, you can write the same code much shorter as a one-liner, attached directly to the component, or to the document:</p> <pre><code>&lt;body ... _=\"on htmx:responseError[detail.xhr.status == 410] window.location.reload()\"&gt;\n...\n&lt;/body&gt;\n</code></pre>"},{"location":"example_project/","title":"Example project","text":"<p>While the fully fledged documentation is not ready and the project is in flux, it's better to use the \"example\" project as the reference.</p> <p>Run it locally and play with it to get a better understanding of how the library works.</p> <pre><code>poetry install\ncd example\ncp env.example .env\npoetry run python manage.py migrate\npoetry run python manage.py runserver\n</code></pre> <p>See example.</p>"},{"location":"execution_results/","title":"Execution Results","text":"<p>Execution results are objects returned from command handlers that control how components respond to user actions. They determine which components need re-rendering, what HTTP headers to set, and how the browser should behave after processing a command.</p>"},{"location":"execution_results/#overview","title":"Overview","text":"<p>Command handlers can return different types of execution results to control the response behavior:</p> <ul> <li>Component rendering control - Mark components as dirty (needing re-render) or clean</li> <li>Navigation control - Redirect to different pages or refresh the current page</li> <li>URL management - Update the browser URL without full page reload</li> </ul> <p>If a command handler returns <code>None</code> (or doesn't return anything), the component is automatically marked as dirty and will be re-rendered.</p>"},{"location":"execution_results/#available-execution-results","title":"Available Execution Results","text":""},{"location":"execution_results/#livecomponents.manager.execution_results.ComponentClean","title":"<code>ComponentClean</code>","text":"<p>Indicate that a component is clean and requires no re-rendering.</p> <p>Use this when a command performs side effects (like logging, analytics, or background tasks) that don't change the component's visual state.</p> <p>Example:</p> <pre><code>class AnalyticsComponent(LiveComponent):\n    ...\n\n    @command\n    def track_click(self, call_context: CallContext[AnalyticsState], event_name: str):\n        \"\"\"Log user action without re-rendering the component\"\"\"\n        self.analytics.track(event_name, call_context.state.user_id)\n        return ComponentClean()\n</code></pre>"},{"location":"execution_results/#livecomponents.manager.execution_results.ComponentDirty","title":"<code>ComponentDirty</code>","text":"<p>Mark a component as dirty to trigger re-rendering.</p> <p>This is the default behavior when a command handler returns None.</p> <p>Example:</p> <pre><code>class StockComponent(LiveComponent):\n    ...\n\n    @command\n    def update_stock(self, call_context: CallContext[StockState]):\n        \"\"\"Update stock quantity. Component automatically re-renders\"\"\"\n        call_context.state.bean.stock_quantity += 1\n        call_context.state.bean.save()\n        # Returns ComponentDirty() by default\n</code></pre>"},{"location":"execution_results/#livecomponents.manager.execution_results.ParentDirty","title":"<code>ParentDirty</code>","text":"<p>Mark the parent component as dirty to trigger re-rendering.</p> <p>Useful when a child component performs an action that affects the parent's data, such as deleting an item from a list or updating shared state.</p> <p>Example:</p> <pre><code>class CartComponent(LiveComponent):\n    ...\n\n    @command\n    def add_to_cart(self, call_context: CallContext[CartState], product_id: int):\n        \"\"\"Add item to cart and update parent cart counter\"\"\"\n        self.state.cart.append(product_id)\n        return ParentDirty()\n</code></pre>"},{"location":"execution_results/#livecomponents.manager.execution_results.RedirectPage","title":"<code>RedirectPage</code>","text":"<p>Redirect the browser to a different URL.</p> <p>Sets the HX-Redirect header to instruct HTMX to navigate to a new page. Commonly used after successful form submissions or authentication.</p> <p>Example:</p> <pre><code>class LoginComponent(LiveComponent):\n    ...\n\n    @command\n    def login(self, call_context: CallContext[LoginState], username: str, password: str):\n        \"\"\"Authenticate user and redirect to dashboard\"\"\"\n        user = authenticate(username=username, password=password)\n        if user:\n            login(call_context.request, user)\n            return RedirectPage('/dashboard/')\n        call_context.state.error = 'Invalid credentials'\n</code></pre>"},{"location":"execution_results/#livecomponents.manager.execution_results.RefreshPage","title":"<code>RefreshPage</code>","text":"<p>Trigger a full page refresh in the browser.</p> <p>Sets the HX-Refresh header to instruct HTMX to reload the entire page. Use sparingly, as it breaks the SPA-like experience.</p> <p>Example:</p> <pre><code>class SettingsComponent(LiveComponent):\n    ...\n\n    @command\n    def switch_language(self, call_context: CallContext[SettingsState], language: str):\n        \"\"\"Switch language and refresh page to apply changes\"\"\"\n        call_context.request.session['language'] = language\n        return RefreshPage()\n</code></pre>"},{"location":"execution_results/#livecomponents.manager.execution_results.ReplaceUrl","title":"<code>ReplaceUrl</code>","text":"<p>Replace the current URL in the browser without reloading the page.</p> <p>Updates the browser's address bar and history without triggering a full page reload. Useful for maintaining clean URLs that reflect the current application state. See https://htmx.org/headers/hx-replace-url/.</p> <p>Example:</p> <pre><code>class ProductListComponent(LiveComponent):\n    ...\n\n    @command\n    def apply_search_filter(self, call_context: CallContext[ProductListState], search_term: str):\n        \"\"\"Apply search filter and update URL to reflect current state\"\"\"\n        call_context.state.search = search_term\n        if search_term:\n            return ReplaceUrl(f'/products/?search={search_term}')\n        else:\n            return ReplaceUrl('/products/')\n</code></pre>"},{"location":"execution_results/#more-usage-examples","title":"More Usage Examples","text":""},{"location":"execution_results/#basic-component-control","title":"Basic Component Control","text":"<p>When you need explicit control over component rendering:</p> <pre><code>from livecomponents import LiveComponent, command, CallContext\nfrom livecomponents.manager.execution_results import ComponentDirty, ComponentClean\n\nclass DataComponent(LiveComponent):\n\n    @command\n    def update_data(self, call_context: CallContext[DataState]):\n        \"\"\"Update component state and trigger re-render\"\"\"\n        call_context.state.data = \"new value\"\n        # Component will be re-rendered (default behavior)\n        return ComponentDirty()\n\n    @command\n    def log_action(self, call_context: CallContext[DataState]):\n        \"\"\"Log user action without triggering component re-render\"\"\"\n        self.analytics.track(\"button_clicked\", call_context.state.user_id)\n        return ComponentClean()\n</code></pre>"},{"location":"execution_results/#cross-component-updates","title":"Cross-Component Updates","text":"<p>When child components need to update their parents or siblings:</p> <pre><code>class ProductRowComponent(LiveComponent):\n\n    @command\n    def update_sibling(self, call_context: CallContext[ProductRowState]):\n        \"\"\"Update product data and refresh related sidebar component\"\"\"\n        self.update_product_stats()\n        return ComponentDirty(\"product-sidebar\")\n\n    @command\n    def delete_product(self, call_context: CallContext[ProductRowState]):\n        \"\"\"Delete product and refresh parent product list\"\"\"\n        call_context.state.product.delete()\n        return ParentDirty()\n</code></pre>"},{"location":"execution_results/#multiple-results","title":"Multiple Results","text":"<p>Command handlers can return a list of execution results to perform multiple actions:</p> <pre><code>class OrderComponent(LiveComponent):\n\n    @command\n    def complete_order(self, call_context: CallContext[OrderState]):\n        \"\"\"Complete order with multiple UI updates\"\"\"\n        order = call_context.state.order\n        order.status = \"completed\"\n        order.save()\n\n        return [\n            ComponentDirty(),  # Re-render current component\n            ComponentDirty(\"cart-counter\"),  # Update cart count\n            ReplaceUrl(f\"/orders/{order.id}/confirmation/\")  # Update URL\n        ]\n</code></pre>"},{"location":"javascript_integration/","title":"Working with JavaScript in Livecomponents","text":"<p>When building livecomponents, you often need client-side JavaScript to work with libraries like Chart.js, Google Maps, Monaco editor, or other interactive components. This is challenging because livecomponents use HTMX for updates, which changes how and when JavaScript runs.</p> <p>This guide explains the common problems and how to fix them.</p>"},{"location":"javascript_integration/#scripts-dont-re-execute-on-updates","title":"Scripts Don't Re-Execute on Updates","text":"<p>What happens: When you include JavaScript directly in your component template, it only runs once on the initial page load. When the component updates via HTMX, the script doesn't run again.</p> <pre><code>&lt;div {% component_attrs component_id %}&gt;\n  &lt;div id=\"my-chart\"&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // This only runs ONCE on initial page load\n    console.log(\"Initializing chart\");\n    new Chart(document.getElementById(\"my-chart\"), config);\n  &lt;/script&gt;\n&lt;/div&gt;\n</code></pre> <p>Why this happens: Livecomponents use Alpine.js morphing to update the page efficiently. Alpine morph doesn't run <code>&lt;script&gt;</code> tags again when updating them (Alpine morph docs).</p> <p>Solutions:</p> <p>As a solution, switch to the regular HTMX update mechanism (without morphing). By default, HTMX will execute scripts on the updated element. You can do this in two ways:</p> <ul> <li>Use <code>swap_style=\"outerHTML\"</code>: Forces HTMX to replace the entire element:</li> </ul> <pre><code>&lt;div {% component_attrs component_id swap_style=\"outerHTML\" %}&gt;\n  &lt;script&gt;\n    // This will run on every update\n  &lt;/script&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>Use <code>{% no_morph %}</code> template tag: Prevents morphing of the script element:</li> </ul> <pre><code>&lt;div {% component_attrs component_id %}&gt;\n  &lt;script {% no_morph %}&gt;\n    // This will run on every update\n  &lt;/script&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"javascript_integration/#multiple-script-execution-with-nested-components","title":"Multiple Script Execution with Nested Components","text":"<p>What happens: When you have nested livecomponents, scripts can execute multiple times unexpectedly.</p> <p>Why this happens: Livecomponents use <code>hx-swap-oob</code> to update components in place. With nested components, HTMX processes multiple <code>hx-swap-oob</code> directives:</p> <ol> <li>Parent component gets swapped</li> <li>Child components also get swapped</li> <li>Scripts in both parent and child run multiple times</li> </ol> <p>Solution: Disable nested out-of-band swaps by adding this to your HTML <code>&lt;head&gt;</code>:</p> <pre><code>&lt;meta name=\"htmx-config\" content='{\"allowNestedOobSwaps\":false}' /&gt;\n</code></pre> <p>This tells HTMX to only process the outermost swap and ignore nested ones. This configuration is recommended in the quickstart guide.</p>"},{"location":"javascript_integration/#managing-javascript-object-references","title":"Managing JavaScript Object References","text":"<p>What happens: JavaScript libraries create objects (like Chart instances) that you need to reuse when your component updates. You need somewhere to store these objects.</p> <p>Recommended approach: Store objects as custom properties on DOM elements:</p> <pre><code>const canvas = document.getElementById(\"my-canvas\");\nif (canvas.chart) {\n  // Update existing chart\n  canvas.chart.update();\n} else {\n  // Create new chart and store reference\n  canvas.chart = new Chart(canvas, config);\n}\n</code></pre> <p>Why this works:</p> <ul> <li>Objects are automatically garbage collected when DOM elements are removed</li> <li>No global namespace pollution</li> <li>Clear association between DOM elements and their JavaScript objects</li> </ul>"},{"location":"javascript_integration/#preserving-stateful-components","title":"Preserving Stateful Components","text":"<p>For components that take time to set up (charts, maps, editors), use <code>hx-preserve</code> to keep DOM elements unchanged during updates:</p> <pre><code>&lt;div {% component_attrs component_id %}&gt;\n  &lt;!-- This content can be updated --&gt;\n  &lt;h3&gt;{{ chart_title }}&lt;/h3&gt;\n\n  &lt;!-- This element stays unchanged --&gt;\n  &lt;canvas id=\"chart-{{ component_id }}\" hx-preserve&gt;&lt;/canvas&gt;\n\n  &lt;script {% no_morph %}&gt;\n    function updateChart() {\n      const canvas = document.getElementById(\"chart-{{ component_id }}\");\n      if (canvas.chart) {\n        // Update existing chart with new data\n        canvas.chart.data = getNewData();\n        canvas.chart.update();\n      } else {\n        // Initialize chart first time\n        canvas.chart = new Chart(canvas, getConfig());\n      }\n    }\n    document.addEventListener(\"htmx:load\", updateChart);\n  &lt;/script&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"javascript_integration/#choosing-the-right-javascript-event","title":"Choosing the Right JavaScript Event","text":"<p>Different events work for different needs:</p> <ul> <li><code>DOMContentLoaded</code> - Only runs on initial page load</li> <li><code>htmx:afterSettle</code> - Runs after HTMX finishes updating content</li> <li><code>htmx:load</code> - Runs when HTMX loads new content (recommended)</li> </ul> <pre><code>// Best for component initialization\ndocument.addEventListener(\"htmx:load\", initializeComponent, { once: true });\n</code></pre> <p>If your component initializes itself on each re-render, consider using <code>{once: true}</code> to ensure your handler executes at most once per element.</p>"},{"location":"javascript_integration/#important-configuration","title":"Important Configuration","text":"<p>Make sure HTMX allows script execution (this is the default):</p> <pre><code>&lt;meta name=\"htmx-config\" content='{\"allowScriptTags\": true}' /&gt;\n</code></pre> <p>Stop scripts from running multiple times with nested components (not default, but recommended):</p> <pre><code>&lt;meta name=\"htmx-config\" content='{\"allowNestedOobSwaps\": false}' /&gt;\n</code></pre>"},{"location":"javascript_integration/#working-example","title":"Working Example","text":"<p>See the Chart.js component in the example project at <code>myapp/components/chart/chart.html</code>. This demonstrates:</p> <ul> <li>Using <code>hx-preserve</code> for the canvas element</li> <li>Storing the Chart.js instance on the DOM element</li> <li>Handling both initialization and updates</li> <li>Using <code>{% no_morph %}</code> for reliable script execution</li> </ul>"},{"location":"javascript_integration/#summary","title":"Summary","text":"<p>Key Points:</p> <p>\u2022 Scripts may not re-run automatically. Use <code>swap_style=\"outerHTML\"</code> or <code>{% no_morph %}</code> to ensure execution \u2022 Disable nested OOB swaps. Add <code>{\"allowNestedOobSwaps\":false}</code> to prevent multiple executions \u2022 Store objects on DOM elements. Avoid global variables, use element properties instead \u2022 Use <code>hx-preserve</code> for stateful components. Keep expensive initializations unchanged \u2022 Listen to <code>htmx:load</code> events. Best for component initialization</p> <p>Essential Links:</p> <ul> <li>HTMX Scripting Documentation - Official guide to JavaScript integration</li> <li>hx-preserve Attribute - Keep elements unchanged during updates</li> <li>hx-swap-oob Attribute - Out-of-band swapping behavior</li> <li>Alpine Morph Plugin - How morphing affects script execution</li> <li>HTMX Configuration - Important configuration options</li> <li>Example Project - Working Chart.js implementation</li> </ul>"},{"location":"livecomponents/","title":"Livecomponent Anatomy","text":""},{"location":"livecomponents/#what-is-a-livecomponent","title":"What is a Livecomponent?","text":"<p>A Livecomponent is a subclass of the Component class from the django-components project. The main goal of django-components is to provide reusable components for Django templates.</p> <p>Livecomponents extend these with dynamic rendering capabilities. Unlike basic components, livecomponents can store their own state and provide actions that can be called from the web page.</p> <p>Here and in some places below, we compare livecomponents with React components. If you are familiar with React, you will notice some similarities.</p> <p>You can think of a regular component from django-components as a React component that only has props and no state. Its appearance is defined purely in the template that calls it and passes arguments (props) to it. In contrast, a livecomponent is like a React component that has both props and state, and can re-render itself in response to user actions.</p> <p>Compatibility with django-components</p> <p>The version of django-components used with Livecomponents is 0.28.3. Since then, the upstream project has advanced significantly and introduced some breaking changes, but we are still using this version for compatibility reasons.</p>"},{"location":"livecomponents/#simple-livecomponent","title":"Simple Livecomponent","text":"<p>We usually store livecomponents in the <code>components</code> directory of the related Django app. For example, for an app called <code>counters</code>, we would store the livecomponents in the <code>counters/components</code> directory.</p> <p>Each component is stored in a separate directory, inside which we keep the Python file with the component class and the Django HTML template, like this:</p> <pre><code>counters/\n    components/\n        simplecounter/\n            simplecounter.py\n            simplecounter.html\n</code></pre> <p>Instead of creating the directory structure manually, you can use the <code>createlivecomponent</code> management command. This command will create the files with boilerplate code and provide brief instructions on how to use them.</p> <p>For example:</p> <pre><code>./manage.py createlivecomponent counters simplecounter\n\nCreated component files: ...\n- If necessary, add 'counters.components.simplecounter.simplecounter' to COMPONENTS['libraries'] in your settings\n- Use component as {% livecomponent \"simplecounter\" %}\n- If the component is called from a parent component, use it as {% livecomponent \"simplecounter\" parent_id=component_id %}\n</code></pre> <p>Assuming the Django project is correctly configured, the component can be inserted on any page with the following syntax:</p> <pre><code>{% load livecomponents %}\n{% livecomponent \"&lt;component_name&gt;\" &lt;component_kwargs&gt; %}\n</code></pre> <p>For example (with no arguments):</p> <pre><code>{% load livecomponents %}\n{% livecomponent \"simplecounter\" %}\n</code></pre> <p>The livecomponent Python classes are defined in the <code>simplecounter.py</code> file. There are usually two classes: the component class and the state class.</p> <ul> <li>The component class is a subclass of the <code>LiveComponent</code> class.</li> <li>The state class is a subclass of the <code>BaseModel</code> class from the <code>pydantic</code> library.</li> </ul>"},{"location":"livecomponents/#component-python-class","title":"Component Python Class","text":"<p>Here's the Python class for the simplecounter component.</p> <p>As you can see, there are two classes: the state class and the component class. The state keeps the counter value, and the component class defines two commands: <code>increment</code> and <code>decrement</code>.</p> <pre><code>from django_components import component\n\nfrom livecomponents import (\n    LiveComponent,\n    LiveComponentsModel,\n    command,\n)\n\n\nclass SimplecounterState(LiveComponentsModel):\n    count: int = 0\n\n\n@component.register(\"simplecounter\")\nclass SimplecounterComponent(LiveComponent[SimplecounterState]):\n    template_name = \"simplecounter/simplecounter.html\"\n\n    def init_state(self, context):\n        return SimplecounterState()\n\n    @command\n    def increment(self, call_context):\n        \"\"\"Example command.\"\"\"\n        call_context.state.count += 1\n\n    @command\n    def decrement(self, call_context):\n        \"\"\"Example command.\"\"\"\n        call_context.state.count -= 1\n</code></pre>"},{"location":"livecomponents/#component-template","title":"Component Template","text":"<p>The template is defined in the <code>simplecounter.html</code> file.</p> <pre><code>{% load livecomponents %}\n\n&lt;div {% component_attrs component_id %}&gt;\n  &lt;button hx-post=\"{% call_command component_id 'decrement' %}\"&gt;-1&lt;/button&gt;\n  &lt;button hx-post=\"{% call_command component_id 'increment' %}\"&gt;+1&lt;/button&gt;\n  &lt;div&gt;Count: {{ count }}&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>The important points here are:</p> <ul> <li>The component must be wrapped with an HTML element (a top-level div in this case).</li> <li>The top-level div must contain the \"magic\" template tag <code>{% component_attrs component_id %}</code>. This tag expands to a set of livecomponent-specific and HTMX-specific attributes that are used to correctly address the element when re-rendering it in response to commands.</li> <li>Actions are defined as HTMX-style POST requests.</li> </ul> <p>The result will look like this:</p> <p></p>"},{"location":"livecomponents/#component-commands","title":"Component Commands","text":"<p>The <code>{% call_command component_id 'increment' %}</code> template tag expands to a URL that looks like this: <code>/livecomponents/call_command/?session_id=&lt;session&gt;&amp;component_id=&lt;component_id&gt;&amp;command_name=&lt;command_name&gt;</code>.</p> <p>On the server side, the command is called by the livecomponent handler, which finds the component class, fetches the state from the store, and calls the command handler. Then the command handler redraws the component and returns the result to the client.</p>"},{"location":"livecomponents/#component-state","title":"Component State","text":"<p>The state is defined in a separate class. The state must include parameters passed to the component as keyword arguments, so that the component gets all the necessary information to re-render itself on partial render.</p> <p>For example, given the template for the alert component:</p> <pre><code>&lt;alert&gt;{{ message }}&lt;/alert&gt;\n</code></pre> <p>that you want to use as</p> <pre><code>{% component \"alert\" message=\"Hello, world!\" %}\n</code></pre> <p>Assuming that the component will be re-rendered on partial render, the state must include the \"message\" parameter:</p> <pre><code>from pydantic import BaseModel\nfrom livecomponents.component import LiveComponent\nfrom livecomponents.manager.manager import InitStateContext\n\nclass AlertState(BaseModel):\n    message: str = \"\"\n\n\nclass Alert(LiveComponent):\n\n    template_name = \"alert.html\"\n\n    def init_state(self, context: InitStateContext) -&gt; AlertState:\n        return AlertState(**context.component_kwargs)\n</code></pre> <p>Component states don't need to be stored if components are not expected to be re-rendered independently, and only as part of the parent component. For example, components for buttons are rarely re-rendered independently, so you can get away without the state model.</p>"},{"location":"livecomponents/#serializing-component-state","title":"Serializing Component State","text":"<p>When the page is rendered for the first time, a new session is created, and each component is initialized with its state by calling the <code>init_state()</code> method.</p> <p>The state is then serialized and stored in the session store, and as long as the session is the same (in other words, while the page is not reloaded), the state is reused.</p> <p>The state is serialized using the <code>StateSerializer</code> class and saved in Redis. By default, the <code>PickleStateSerializer</code> is used. The serializer uses a custom pickler and is optimized to effectively store the most common types of data used in a Django app. More specifically:</p> <ul> <li>When serializing a Django model, only the model's name and primary key are stored. The serializer takes advantage of the persistent_id/persistent_load pickle mechanism.</li> <li>When serializing a Pydantic model, only the model's name and the values of the fields are stored.</li> <li>When serializing a Django form, only the form's class name, as well as initial data and data, are stored.</li> </ul> <p>Session Storage Size Warning</p> <p>Livecomponents use Redis as the session store. Remember that a new session is created for each page load of every client, and stored there for 24 hours by default. This means you should keep the state small.</p>"},{"location":"livecomponents/#stateless-components","title":"Stateless components","text":"<p>If the component doesn't store any state, you can inherit from the StatelessLiveComponent class. You may find this helpful for rendering a hierarchy of components where the shared state is stored in the root components.</p> <pre><code>from livecomponents.component import StatelessLiveComponent\n\nclass StatelessAlert(StatelessLiveComponent):\n\n    template_name = \"alert.html\"\n\n    def get_extra_context_data(\n        self, extra_context_request: \"ExtraContextRequest[State]\"\n    ) -&gt; dict:\n        state_manager = extra_context_request.state_manager\n        root_addr = extra_context_request.state_addr.must_find_ancestor(\"root\")\n        root_state = state_manager.get_component_state(root_addr)\n        return {\"message\": root_state.message}\n</code></pre>"},{"location":"livecomponents/#returning-results-from-command-handlers","title":"Returning results from command handlers","text":"<p>Command handlers can return execution results to control component rendering and browser behavior. Here's the basic signature:</p> <pre><code>from livecomponents import LiveComponent, CallContext, command\nfrom livecomponents.manager.execution_results import IExecutionResult\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def my_command_handler(self, call_context: CallContext, **kwargs) -&gt; list[IExecutionResult] | IExecutionResult | None:\n        ...\n</code></pre> <p>If a command handler returns <code>None</code> (or doesn't return anything), the component is automatically marked as dirty and will be re-rendered.</p> <p>For detailed information about all available execution results and their usage, see the Execution Results reference.</p>"},{"location":"livecomponents/#raising-exceptions-from-command-handlers","title":"Raising exceptions from command handlers","text":"<p>In some rare scenarios, you may need to cancel rendering the component and instruct the command handler to return an empty string to the client.</p> <p>If this is the case, you can raise a <code>livecomponents.exceptions.CancelRendering()</code> exception.</p> <p>The exception can be raised directly from a command handler or from one of the methods that it calls, such as <code>get_extra_context_data()</code>.</p> <pre><code>from livecomponents.exceptions import CancelRendering\n...\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def my_command_handler(self, call_context: CallContext, **kwargs):\n        if not self.pre_condition_met(call_context):\n            raise CancelRendering()\n        ...\n</code></pre> <p>We encountered this situation at least once, where a race condition caused the pre-condition that was true when we started executing a command to no longer be true when we rendered a sub-component. In this case, we couldn't render the sub-component but also didn't want to return a partially rendered component. The best solution was to return an empty string, effectively making the command have no effect.</p>"},{"location":"livecomponents/#calling-component-methods-from-others","title":"Calling component methods from others","text":"<p>There are several ways to call component methods from other components:</p> <p>Using the component ID. For example, if you have a component with ID \"|message.0\" and a method \"set_message\", you can call it like this:</p> <pre><code>from livecomponents import LiveComponent, command, CallContext\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def do_something(self, call_context: CallContext):\n        call_context.find_one(\"|message:0\").set_message(\"Hello, world!\")\n</code></pre> <p>Using the \"parent\" reference.</p> <pre><code>from livecomponents import LiveComponent, command, CallContext\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def do_something(self, call_context: CallContext):\n        call_context.parent.set_message(\"Hello, world!\")\n</code></pre>"},{"location":"management_commands/","title":"Management commands","text":""},{"location":"management_commands/#management-commands","title":"Management Commands","text":""},{"location":"management_commands/#createlivecomponent","title":"<code>createlivecomponent</code>","text":""},{"location":"management_commands/#description","title":"Description","text":"<p>The <code>createlivecomponent</code> command is used to quickly create a new livecomponent. This command generates the necessary Python and HTML files for the component.</p>"},{"location":"management_commands/#arguments","title":"Arguments","text":""},{"location":"management_commands/#positional-arguments","title":"Positional Arguments","text":"<ul> <li><code>app_name</code> (str): The name of the app. E.g., 'counters'.</li> <li><code>component_name</code> (str): Component name in snake case. The name can use directory separator for creating namespaces. Normally, the first namespace is the app name. E.g., 'counters/click_counter'.</li> </ul>"},{"location":"management_commands/#optional-arguments","title":"Optional Arguments","text":"<ul> <li><code>--class-name</code> (str): Optional class name for the component. E.g., 'ClickCounter'. If not given, the component name, converted to PascalCase, is used.</li> <li><code>-f</code>, <code>--force</code> (bool): Overwrite existing files. Default is <code>False</code>.</li> <li><code>--stateless</code> (bool): Create a stateless component. Default is <code>False</code>.</li> <li><code>--minimal</code> (bool): Create a minimal component without any commands. Default is <code>False</code>.</li> <li><code>--base-class</code> (str): Base class for the component. If not given, value from settings is used.</li> </ul>"},{"location":"management_commands/#usage-examples","title":"Usage Examples","text":""},{"location":"management_commands/#basic-usage","title":"Basic Usage","text":"<pre><code>python manage.py createlivecomponent counters counters/click_counter\n</code></pre> <p>This command will create the files:</p> <ul> <li><code>counters/components/counters/click_counter/click_counter.py</code> (Python file with the component class)</li> <li><code>counters/components/counters/click_counter/click_counter.html</code> (HTML template for the component)</li> </ul>"},{"location":"management_commands/#create-minimal-statless-component","title":"Create Minimal Statless Component","text":"<pre><code>python manage.py createlivecomponent counters counters/click_counter --stateless --minimal\n</code></pre>"},{"location":"management_commands/#settings-options","title":"Settings Options","text":""},{"location":"management_commands/#base-class-name","title":"Base Class Name","text":"<p>The base class name for the component can be configured in the Django settings under the <code>LIVECOMPONENTS</code> configuration. Example:</p> <pre><code># myproject/utils.py\nimport abc\nfrom typing import Generic\nfrom livecomponents import LiveComponent, StatelessLiveComponent\nfrom livecomponents.types import State\n\n\nclass MyLiveComponent(LiveComponent, abc.ABC, Generic[State]):\n    class Media:\n        js = [\"myproject/livecomponent.js\"]\n\n\nclass MyStatelessLiveComponent(StatelessLiveComponent):\n    class Media:\n        js = [\"myproject/livecomponent.js\"]\n</code></pre> <pre><code># settings.py\nLIVECOMPONENTS = {\n    # ...\n    # Settings for the \"./manage.py createlivecomponent\" command.\n    \"createlivecomponent\": {\n        \"base_class\": \"myproject.utils.MyLiveComponent\",\n        \"stateless_base_class\": \"myproject.utils.MyStatelessLiveComponent\",\n    },\n}\n</code></pre>"},{"location":"nested_components/","title":"Nested Livecomponents","text":"<p>While livecomponents can be used as standalone components, they can also be nested. This approach allows you to split complex user interfaces into smaller components and develop them independently.</p> <p>Although you can create advanced nested livecomponents, there are several caveats to be aware of. We've found that it's much easier to reason about the livecomponents lifecycle using the \"root with stateless children\" pattern.</p> <p>Let's explore this pattern in detail.</p>"},{"location":"nested_components/#root-with-stateless-children","title":"Root with stateless children","text":"<p>The idea behind this pattern is to create a single component (typically called \"myapp/root\") that maintains the entire state and contains all the actions that can modify this state.</p> <p>Child components are stateless and don't have any actions. Their Django templates call the actions defined in their root component.</p> <p>While this approach makes the root and child components tightly coupled (you can't use child components independently), it makes the data flow easier to understand. Additionally, all logic is concentrated in a single place.</p>"},{"location":"nested_components/#nested-counter-example","title":"Nested Counter Example","text":"<p>Let's start by creating a view and a template that renders the root component.</p> <pre><code># counters/views.py\n\ndef nestedcounter(request: HttpRequest):\n    return render(request, \"nestedcounter.html\")\n</code></pre> <pre><code># templates/nestedcounter.html\n\n{% extends \"base.html\" %}\n{% load livecomponents %}\n\n{% block body %}\n  &lt;h1&gt;Nested counter&lt;/h1&gt;\n  {% livecomponent \"nestedcounter/root\" %}\n{% endblock %}\n</code></pre> <p>Since the nested counter components don't exist yet, let's first create a placeholder for the root component. We'll create a root component that will maintain the counter state.</p> <pre><code>./manage.py createlivecomponent counters nestedcounter/root ./manage.py\n</code></pre> <p>Now, let's modify the root component to define the state and action.</p> <pre><code>class RootState(LiveComponentsModel):\n    value: int = 0\n\n\n@component.register(\"nestedcounter/root\")\nclass RootComponent(LiveComponent[RootState]):\n\n    ...\n\n    @command\n    def increment(self, call_context: CallContext[RootState], value: int):\n        \"\"\"Increment the counter.\"\"\"\n        call_context.state.value += value\n</code></pre> <p>In this simple example, we could create both the current value display and the increment button in the same template like this:</p> <pre><code>{% load livecomponents %}\n\n&lt;div {% component_attrs component_id %}&gt;\n    Counter: {{ value }}\n    &lt;button {% component_attrs component_id %}\n        hx-post='{% call_command component_id \"increment\" %}'\n        hx-vals='{\"value\": 1}'\n    &gt;\n        +1\n    &lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>However, for demonstration purposes, let's extract the button into a separate stateless component.</p> <p>Let's update the root component's HTML to use the new button component:</p> <pre><code>{% load livecomponents %}\n\n&lt;div {% component_attrs component_id %}&gt;\n    Counter: {{ value }}\n    {% livecomponent \"nestedcounter/button\" parent_id=component_id %}\n&lt;/div&gt;\n</code></pre> <p>The <code>parent_id</code> argument</p> <p>The <code>parent_id=component_id</code> argument is crucial for building the component hierarchy. It passes the ID of the parent component to the child component, establishing their relationship.</p> <p>Now, let's create the button component placeholder:</p> <pre><code>createlivecomponent counters nestedcounter/button --stateless --minimal\n</code></pre> <p>The Python code for the button can remain minimal since it's stateless:</p> <pre><code>from django_components import component\n\nfrom livecomponents import StatelessLiveComponent\n\n\n@component.register(\"nestedcounter/button\")\nclass ButtonComponent(StatelessLiveComponent):\n    template_name = \"nestedcounter/button/button.html\"\n</code></pre> <p>The HTML code will look like this:</p> <pre><code>{% load livecomponents %}\n{% component_ancestor component_id \"nestedcounter/root\" as root_id %}\n\n&lt;button {% component_attrs component_id %}\n    hx-post='{% call_command root_id \"increment\" %}'\n    hx-vals='{\"value\": 1}'\n&gt;\n    +1\n&lt;/button&gt;\n</code></pre> <p>The key part is the <code>{% component_ancestor component_id \"nestedcounter/root\" as root_id %}</code> line. This allows the button component to call the <code>increment</code> command on the root component.</p> <p>Note that if the parent component doesn't include the <code>parent_id=component_id</code> argument, the <code>component_ancestor</code> tag will return an empty string, and the command call will fail.</p>"},{"location":"nested_components/#hierarchy-implementation-details","title":"Hierarchy Implementation Details","text":"<p>When rendering a page, the component hierarchy is stored in the livecomponent IDs, which remain stable across page loads.</p> <p>For an isolated component, the ID format is simple:</p> <pre><code>|&lt;component_type&gt;:&lt;own_id&gt;\n</code></pre> <p>Here, <code>component_type</code> is the livecomponent name (like \"my_button\" or \"nestedcounter/button\"), and <code>own_id</code> is the component's ID. If no component ID is provided, it defaults to 0.</p> <p>For hierarchical components, the ID encodes the entire hierarchy as a concatenation of the parent ID, component type, and component ID:</p> <pre><code>|&lt;parent_type&gt;:&lt;parent_id&gt;|...|&lt;component_type&gt;:&lt;own_id&gt;\n</code></pre> <p>This is where the <code>parent_id=component_id</code> argument comes into play - it passes the parent ID to build the full component ID for the child.</p> <p>All other features, such as calling <code>parent</code> from the component or using the <code>component_ancestor</code> template tag, are convenience methods for working with the hierarchy. These functions and template tags parse the ID string similarly to how Python's <code>os.path</code> handles file paths.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Here's how you integrate live components after you've installed the package:</p> <ul> <li>Modify Django settings.</li> <li>Modify base HTML template.</li> <li>Modify URLs to include live components.</li> </ul>"},{"location":"quickstart/#django-settings","title":"Django settings","text":"<p>Add to installed apps following packages:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    \"django_components\",\n    \"django_components.safer_staticfiles\",\n    \"django_htmx\",\n    \"livecomponents\",\n    # ...\n]\n</code></pre> <p>Add HTMX middleware:</p> <pre><code>MIDDLEWARE = [\n    # ...\n    \"django_htmx.middleware.HtmxMiddleware\",\n    # ...\n]\n</code></pre> <p>Add component dirs for to static files:</p> <pre><code># Static files (CSS, JavaScript, Images)\nSTATICFILES_DIRS = [\n    # To load django-components specific to myapp\n    BASE_DIR / \"app_one/components\",\n    BASE_DIR / \"app_two/components\",\n]\n</code></pre> <p>You can also configure live components with the <code>LIVECOMPONENTS</code> settings dictionary. See the \"Configuration\" section for more details.</p>"},{"location":"quickstart/#base-template","title":"Base template","text":"<p>There, we need support for HTMX and Live Components:</p> <pre><code>{% load ... component_tags django_htmx livecomponents %}\n&lt;head&gt;\n  &lt;!-- Configure HTMX. See https://htmx.org/docs/#config --&gt;\n  &lt;meta name=\"htmx-config\" content='{\"defaultSwapStyle\":\"none\",\"allowNestedOobSwaps\":false}'&gt;\n\n  &lt;!-- HTMX and plugins --&gt;\n  &lt;script src=\"https://unpkg.com/htmx.org@2.x.x\"&gt;&lt;/script&gt;\n  &lt;script src=\"https://unpkg.com/htmx-ext-json-enc@2.x.x/json-enc.js\"&gt;&lt;/script&gt;\n  &lt;script src=\"https://unpkg.com/htmx-ext-alpine-morph@2.x.x/alpine-morph.js\"&gt;&lt;/script&gt;\n  &lt;!-- Alpine Plugins --&gt;\n  &lt;script defer src=\"https://unpkg.com/@alpinejs/morph@3.x.x/dist/cdn.min.js\"&gt;&lt;/script&gt;\n  &lt;!-- Alpine Core --&gt;\n  &lt;script defer src=\"https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\"&gt;&lt;/script&gt;\n\n  {% django_htmx_script %}\n\n  {% component_css_dependencies %}\n  {% livecomponents_session_id as LIVECOMPONENTS_SESSION_ID %}\n\n  &lt;script&gt;\n    // Optionally, clear the session on page unload.\n    //\n    // Firefox does not support keepalive fetches, so we need to use a workaround.\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon\n    // and https://bugzilla.mozilla.org/show_bug.cgi?id=1342484\n    const fetchUrl = \"{% url 'livecomponents:clear-session' %}?session_id={{ LIVECOMPONENTS_SESSION_ID }}\";\n    const csrfmiddlewaretoken = \"{{ csrf_token }}\";\n    window.addEventListener(\"beforeunload\", function () {\n        navigator.sendBeacon(fetchUrl, new URLSearchParams({csrfmiddlewaretoken}))\n    });\n\n    // Alternatively, use a regular fetch if you don't care about the issue above.\n    // window.addEventListener(\"beforeunload\", function () {\n    //   fetch(fetchUrl, {\n    //     keepalive: true,\n    //     method: \"POST\",\n    //     headers: {\"X-CSRFToken\": csrfmiddlewaretoken}\n    //   });\n    // });\n  &lt;/script&gt;\n  ...\n&lt;/head&gt;\n&lt;body hx-ext=\"alpine-morph, json-enc\" hx-headers='{\"X-CSRFToken\": \"{{ csrf_token }}\"}'&gt;\n...\n{% component_js_dependencies %}\n&lt;/body&gt;\n&lt;html&gt;\n</code></pre>"},{"location":"quickstart/#urls","title":"URLs","text":"<pre><code>from django.urls import path, include\n\nurlpatterns = [\n    # ...\n    path(\"livecomponents/\", include(\"livecomponents.urls\")),\n    # ...\n]\n</code></pre>"},{"location":"quickstart/#create-new-component","title":"Create new component","text":"<p>There is a management command to create new component:</p> <pre><code>./manage.py createlivecomponent &lt;app_name&gt; &lt;directory/component_name&gt;\n</code></pre> <p>The command with create a \"components\" subdirectory in the app directory and create a new component, consisting of one Python, and one HTML file.</p> <p>Make sure that your STATICFILES_DIRS setting includes the \"components\" directory of the app.</p> <p>Optionally, you can pass a <code>--stateless</code> flag to create a stateless component.</p>"},{"location":"templates/","title":"On Storing Raw HTML Templates","text":"<p>In Django-components, the same component can be represented as a flat node <code>{% component \"name\" key=value %}</code> or as a block node to populate slots:</p> <pre><code>{% component_block \"name\" key=value %}\n  {% fill \"slot_name\" %}\n    {{ variable_from_outer_context }}\n  {% endfill %}\n{% endcomponent_block %}\n</code></pre> <p>Rendering components with slots is non-trivial for two reasons:</p> <ul> <li>We need to store the Django HTML content of the slot.</li> <li>It should be possible to re-render the component in isolation without accessing the outer context.</li> </ul> <p>By the time the component is rendered with the <code>@register.tag()</code> function, we don't have access to the raw template content, only to tokens (generated from the raw template by Lexer) and to nodes (generated from the tokens by Parser).</p>"},{"location":"templates/#how-do-we-store-templates","title":"How Do We Store Templates","text":"<p>We introduce new flat tags \"livecomponent\" and block tags \"livecomponent_block\". While building the node (LiveComponentNode instead of ComponentNode of django-components), store the raw template content in the node. When the node is rendered, we associate the raw template content with the component ID to reuse it on re-render.</p>"},{"location":"templates/#more-on-storing-templates","title":"More on Storing Templates","text":"<p>It would be wasteful to store the entire HTML template for every component, considering that most components are rendered by the same template. To optimize space, we hash the template content and use it as the cache key:</p> <pre><code>127.0.0.1:6379&gt; get template_cache:LkAl5ah3\n\"{% livecomponent \\\"search\\\" parent_id=component_id search=search %}\"\n</code></pre> <p>Then, we have a separate Redis HASH \"templates:\" to map from component IDs to template hashes: <pre><code>127.0.0.1:6379&gt; hgetall templates:a99377ffe6a946e496542ac2c8a8cb96\n 1) \"/table.0\"\n 2) \"rPOwF_re\"\n 3) \"/table.0/search.0\"\n 4) \"LkAl5ah3\"\n ...\n</code></pre>"},{"location":"templates/#how-do-we-store-the-outer-context","title":"How Do We Store the Outer Context","text":"<p>However, we need to store the outer context, or rather, the variables from the outer context that are necessary to re-render the template.</p> <p>Here, there's not much we can do: we don't want to store the entire context in Redis because it's wasteful, hard to implement (not everything can be pickled), and can easily go out of sync.</p> <p>Instead, we offload this work to the component developer. The <code>init_state()</code> method for constructing the component state is called on the first render. There, a context variable has an \"outer_context\" attribute. The component developer can store any variables from the outer context in the state and then use them to re-render the component. As long as the developer uses the same name for the variable, the component will be re-rendered correctly.Here's an example:</p> <pre><code>class SampleState(BaseModel):\n    var: str = \"unset\"\n    ...\n\nclass Sample(LiveComponent):\n    ...\n\n    def init_state(self, context: InitStateContext) -&gt; SampleState:\n        var = context.outer_context.get(\"var\", \"unset\")\n        effective_kwargs = {**context.component_kwargs, \"var\": var}\n        return SampleState(**effective_kwargs)\n</code></pre>"},{"location":"templatetags/","title":"Templatetags","text":"<p>All templatetags are loaded with the \"livecomponents\" tag library:</p> <pre><code>{% load livecomponents %}\n</code></pre>"},{"location":"templatetags/#component_attrs","title":"component_attrs","text":"<p>Set \"data-livecomponent-id\", \"hx-swap-oob\", and \"key\" attributes for the root tag of the component. It is expected to be used in every component template.</p> <p>The <code>swap_style</code> parameter controls how the component updates its state (defaults to \"morph\"). See hx-swap-oob for more details.</p> <p>Usage example:</p> <pre><code>&lt;div {% component_attrs component_id %}&gt;\n  &lt;!-- The actual component content --&gt;\n&lt;/div&gt;\n</code></pre> <p>Usage with custom swap style:</p> <pre><code>&lt;div {% component_attrs component_id swap_style=\"outerHTML\" %}&gt;\n  &lt;!-- The actual component content --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"templatetags/#call_command","title":"call_command","text":"<p>Return the URL for calling a command on a component. The <code>component_id</code> argument is the component ID that is available in the render context. The <code>command_name</code> argument is the name of the command to call.</p> <p>Usage example:</p> <pre><code>&lt;button hx-post='{% call_command component_id \"my_command\" %}'&gt;Click me&lt;/button&gt;\n</code></pre> <p>Another example: passing arguments to the command</p> <p>Arguments are passed as JSON-encoded object in the <code>hx-vals</code> attribute.</p> <pre><code>&lt;button hx-post='{% call_command component_id \"my_command\" %}' hx-vals='{\"param\":\"value\"}'&gt;Click me&lt;/button&gt;\n</code></pre>"},{"location":"templatetags/#component_id","title":"component_id","text":"<p>Construct the component ID, built from type and ID pairs, following one after another.</p> <p>For example:</p> <pre><code>{% component_id \"table\" \"primary\" \"row\" 1 \"cell\" \"x\" as cell_x %}\n</code></pre> <p>will return</p> <pre><code>|table:primary|row:1|cell:x\n</code></pre>"},{"location":"templatetags/#component_ancestor","title":"component_ancestor","text":"<p>Return the ID of the closest ancestor component of the given type.</p> <p>For example, if the current component is <code>|table:primary|row:1|cell:x</code>, then</p> <pre><code>{% component_ancestor component_id \"table\" %}\n</code></pre> <p>Will return \"|table:primary\".</p> <p>Usage example:</p> <p>This is useful if the component state is stored in the root component, and managed by it. Below is a contrived example of how you can delete a specific row from the table, assuming that the table state is stored in the root component, and the current component (a row) keeps its ID in the \"row_id\" variable.</p> <pre><code>{% component_ancestor component_id \"table\" as table_id %}\n&lt;button hx-post='{% call_command table_id \"delete_row\" %}' hx-vals='{\"row_id\": {{ row_id }}}'&gt;Delete row&lt;/button&gt;\n</code></pre>"},{"location":"templatetags/#component_selector","title":"component_selector","text":"<p>Return the CSS selector for the component with the given ID.</p> <p>Can be used to select the component in JavaScript code. For example:</p> <pre><code>const element = document.querySelector({% component_selector component_id %});\n</code></pre> <p>Note that the returned value is already quoted, so you don't need to add quotes around it.</p>"},{"location":"templatetags/#no_morph","title":"no_morph","text":"<p>Return a key that disables morphing for the component.</p> <p>Random key is generated to prevent morphing of the component. See Apline.js morph keys for more details.</p> <p>Warning</p> <p><code>no_morph</code> should not be used together with <code>component_attrs</code> on the root element, as both set the <code>key</code> attribute which will cause conflicts. Instead, use <code>{% component_attrs swap_style=\"outerHTML\" %}</code> on the root element to achieve similar behavior.</p> <p>Usage example:</p> <pre><code>&lt;textarea {% no_morph %}&gt;&lt;/textarea&gt;\n</code></pre> <p>This way, the textarea DOM element will always be replaced, not morphed, which, for example, results in updating the component state from the server side.</p>"},{"location":"uploads/","title":"Handling Uploads","text":"<p>By default, the command handler accepts JSON-encoded data passed in the POST request. The HTMX extension <code>json-ext</code>, which we include in the base template, is responsible for this behavior. However, JSON-encoded data cannot include files, so we need to use the <code>multipart/form-data</code> encoding for this purpose.</p> <p>To process the files, create a file upload form in the HTML template of the component. Disable <code>json-ext</code> and explicitly set up the <code>multipart/form-data</code> encoding for the uploaded data. Then, include one or more file upload elements in the form.</p> <p>In the Python handler, uploaded files are available in the <code>call_context.request.FILES</code> variable. The rest of the form goes to the command kwargs, as usual.</p> <p>Here's an example of how the sample file upload form can look. Notice the <code>hx-ext=\"ignore:json-enc\"</code> attribute that disables the <code>json-ext</code> extension for this form.</p> <pre><code>  &lt;form hx-ext=\"ignore:json-enc\" hx-encoding='multipart/form-data' hx-post=\"{% call_command component_id \"upload_file\" %}\"&gt;\n      &lt;input type=\"file\" name=\"csv_file\" placeholder=\"CSV file\" required&gt;\n      &lt;button type=\"submit\"&gt;Upload CSV file&lt;/button&gt;\n  &lt;/form&gt;\n</code></pre> <p>Here's an example of how the handler can look:</p> <pre><code>    ...\n\n    @command\n    def upload_file(self, call_context: CallContext):\n        csv_file = call_context.request.FILES[\"csv_file\"]\n        ...\n</code></pre> <p>You can see a full example in the uploads app of the sample project.</p>"}]}