{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Django Live Component is a library to create dynamic web applications that handle user interaction with the DOM on the server. It relies on Django, HTMX, and Alpine.js to provide a seamless experience for developers and users.</p> <p>To get started, follow the quickstart guide</p>"},{"location":"component_ids/","title":"Component IDs","text":"<ul> <li>Every component must have a root element that includes its ID. The ID is <code>id={{ component_id }}</code>.</li> <li>Component IDs represent the component hierarchy and are formatted as \"|parent:id|child:id\". For example, we can have a component |form:0|button:submit where \"button\" is the component type, \"submit\" is its name, and \"form:0\" is its parent.</li> </ul> <p>In many contexts, you get access to the StateAddress object, which consists of the session ID and the component ID. In this pair, the component ID is a \"ComponentId\" instance (a subclass of str), which has a helpful method to create child items.</p> <p>It can be used like this, without explicitly setting the child own_id:</p> <pre><code>state_address.component_id | \"child_component\"\n</code></pre> <p>Or like this, with explicitly setting the child own_id:</p> <pre><code>state_address.component_id | (\"child_component\", \"child_own_id\")\n</code></pre>"},{"location":"components/","title":"Components","text":""},{"location":"components/#component-state","title":"Component State","text":"<p>The state is defined in a separate class. The state must include parameters, passed to the component as keyword arguments, so that the component gets all necessary information to re-render itself on partial render.</p> <p>For example, given the template the alert component:</p> <pre><code>&lt;alert&gt;{{ message }}&lt;/alert&gt;\n</code></pre> <p>that you want to use as</p> <pre><code>{% component \"alert\" message=\"Hello, world!\" %}\n</code></pre> <p>Assuming that the component will be re-rendered on partial render, the state must include the \"message\" parameter:</p> <pre><code>from pydantic import BaseModel\nfrom livecomponents.component import LiveComponent\nfrom livecomponents.manager.manager import InitStateContext\n\nclass AlertState(BaseModel):\n    message: str = \"\"\n\n\nclass Alert(LiveComponent):\n\n    template_name = \"alert.html\"\n\n\n    def init_state(self, context: InitStateContext) -&gt; AlertState:\n        return AlertState(**context.component_kwargs)\n</code></pre> <p>Component states don't need to be stored if components are not expected to be re-rendered independently, and only as part of the parent component. For example, components for buttons are rarely re-rendered independently, so you get away without the state model.</p>"},{"location":"components/#serializing-component-state","title":"Serializing Component State","text":"<p>When the page is rendered for the first time, a new session is created, and each component is initialized with its state by calling the <code>init_state()</code> method.</p> <p>The state is then serialized and stored in the session store, and as long as the session is the same (in other words, while the page is not loaded), the state is reused.</p> <p>The state is serialized using the <code>StateSerializer</code> class and saved in Redis. By default, the <code>PickleStateSerializer</code> is used. The serializer uses custom pickler and is optimized to store effectively the most common types of data, used in a Django app. More specifically:</p> <ul> <li>When serializing a Django model, only the model's name and primary key are stored. The serializer takes advantage of   the persistent_id/persistent_load pickle mechanism.</li> <li>When serializing a Pydantic model, only the model's name and the values of the fields are stored.</li> <li>When serializing a Django form, only the form's class name, as well as initial data and data, are stored.</li> </ul>"},{"location":"components/#stateless-components","title":"Stateless components","text":"<p>If the component doesn't store any state, you can inherit it from the StatelessLiveComponent class. You may find it helpful for rendering the hierarchy of components where the shared state is stored in the root components.</p> <pre><code>from livecomponents.component import StatelessLiveComponent\n\nclass StatelessAlert(StatelessLiveComponent):\n\n    template_name = \"alert.html\"\n\n    def get_extra_context_data(\n        self, extra_context_request: \"ExtraContextRequest[State]\"\n    ) -&gt; dict:\n        state_manager = extra_context_request.state_manager\n        root_addr = extra_context_request.state_addr.must_find_ancestor(\"root\")\n        root_state = state_manager.get_component_state(root_addr)\n        return {\"message\": root_state.message}\n</code></pre>"},{"location":"components/#returning-results-from-command-handlers","title":"Returning results from command handlers","text":"<p>Here's the signature of the Livecomponent function:</p> <pre><code>from livecomponents import LiveComponent, CallContext, command\nfrom livecomponents.manager.execution_results import IExecutionResult\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def my_command_handler(self , call_context: CallContext, **kwargs) -&gt; list[IExecutionResult] | IExecutionResult | None :\n        ...\n</code></pre> <p>Notice the type of the returned value for the handler. If set to something other than None, it can shape the partial HTTP response.</p> <p>More specifically here's what you can do:</p> <ul> <li>Return ComponentDirty() to mark the component as dirty. This will result in the component being re-rendered and sent to the client. This is the default behavior. If you don't return anything, the component will be marked as dirty.</li> <li>Return ComponentDirty(component_id) to mark a different component as dirty.</li> <li>Return ComponentClean() to mark the current component as clean (not needing re-rendering).</li> <li>Return ParentDirty() to mark the parent component as dirty.</li> <li>Return RefreshPage(). If the command returns RefreshPage(), a \"HX-Refresh: true\" header will be sent to the client.</li> <li>Return RedirectPage(url). If the command returns Redirect(), a \"HX-Redirect: url\" header will be sent to the client.</li> <li>Return ReplaceUrl(url). If the command returns ReplaceUrl(), a \"HX-Replace: url\" header will be sent to the client. This will replace the current URL in the browser without reloading the page.</li> </ul>"},{"location":"components/#raising-exceptions-from-command-handlers","title":"Raising exceptions from command handlers","text":"<p>In some rare scenarios, you may need to cancel rendering the component and instruct the command handler to return an empty string to the client.</p> <p>If this is the case, you can raise a <code>livecomponents.exceptions.CancelRendering()</code> exception.</p> <p>The exception can be raised directly from a command handler or from one of the methods that it will call, such as <code>get_extra_context_data()</code>.</p> <pre><code>from livecomponents.exceptions import CancelRendering\n...\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def my_command_handler(self, call_context: CallContext, **kwargs):\n        if not self.pre_condition_met(call_context):\n            raise CancelRendering()\n        ...\n</code></pre> <p>We encountered this situation at least once, where a race condition caused the pre-condition that was true when we started executing a command to no longer be true when we rendered a sub-component. In this case, we couldn't render the sub-component but also didn't want to return a partially rendered component. The best solution was to return an empty string, effectively making the command have no effect.</p>"},{"location":"components/#calling-component-methods-from-others","title":"Calling component methods from others","text":"<p>There are several ways to call component methods from other components:</p> <p>Using the component ID. For example, if you have a component with ID \"|message.0\" and a method \"set_message\", you can call it like this:</p> <pre><code>from livecomponents import LiveComponent, command, CallContext\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def do_something(self, call_context: CallContext):\n        call_context.find_one(\"|message:0\").set_message(\"Hello, world!\")\n</code></pre> <p>Using the \"parent\" reference.</p> <pre><code>from livecomponents import LiveComponent, command, CallContext\n\nclass MyComponent(LiveComponent):\n\n    @command\n    def do_something(self, call_context: CallContext):\n        call_context.parent.set_message(\"Hello, world!\")\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The application is configured with the \"LIVECOMPONENTS\" dictionary in the settings.py file. Here's the default settings:</p> <pre><code>LIVECOMPONENTS = {\n    \"state_serializer\": {\n        \"cls\": \"livecomponents.manager.serializers.PickleStateSerializer\",\n        \"config\": {},\n    },\n    \"state_store\": {\n        # You can also use \"MemoryStateStore\" for tests.\n        \"cls\": \"livecomponents.manager.stores.RedisStateStore\",\n        # See \"RedisStateStore\" constructor for config options.\n        \"config\": {},\n    },\n    \"state_manager\": {\n        \"cls\": \"livecomponents.manager.manager.StateManager\",\n        \"config\": {},\n    },\n}\n</code></pre>"},{"location":"context/","title":"Storing Component Context","text":"<p>During the first render, components use the entire page context to render themselves.</p> <p>During subsequent renders, components by default use the context populated from their state.</p> <p>However, it is possible to save some variables from the context of the first render. To do this, pass the <code>save_context</code> variable with a comma-separated list of variables that need to be sent to the <code>livecomponent</code> templatetag.</p> <p>This approach is commonly used when working with live component slots.</p> <p>Let's first look at an example of a \"non-prepared\" component that will only work on the first render:</p> <pre><code>{% livecomponent_block \"alert\" %}\n  {% fill \"body\" %}Sending a message to {{ user.email }}!{% endfill %}\n{% endlivecomponent_block %}\n</code></pre> <p>This will not work on partial renders because the component will be rendered without the \"user\" variable.</p> <p>To address this, add the \"save_context\" variable:</p> <pre><code>-{% livecomponent_block \"alert\" %}\n+{% livecomponent_block \"alert\" save_context=\"user\" %}\n   {% fill \"body\" %}Sending a message to {{ user.email }}!{% endfill %}\n {% endlivecomponent_block %}\n</code></pre>"},{"location":"decorators/","title":"Decorators","text":"<p>LiveComponents provide a method decorator to ensure the user is authenticated.</p> <pre><code>from livecomponents import LiveComponent, InitStateContext, CallContext\nfrom livecomponents.decorators import livecomponents_login_required\n\n\nclass Something(LiveComponent):\n\n    @classmethod\n    @livecomponents_login_required\n    def init_state(cls, context: InitStateContext):\n        ...\n\n    @classmethod\n    @livecomponents_login_required\n    def do_something(cls, call_context: CallContext[SomethingState], **kwargs):\n        ...\n</code></pre>"},{"location":"error_handling/","title":"Error handling","text":"<p>The response to calling the command can be an HTTP error. If the command handler fails to find a session, it will return an HTTP 410 Gone error.</p> <p>You can handle this error on the client side. For example, here a JavaScript code snippet to reload the page on the error 410.</p> <pre><code>document.addEventListener(\"htmx:responseError\", function (event) {\n    const statusCode = event.detail.xhr.status;\n    if (statusCode === 410) {\n        document.location.reload();\n    }\n});\n</code></pre> <p>If you use hyperscript, you can write the same code much shorter as a one-liner, attached directly to the component, or to the document:</p> <pre><code>&lt;body ... _=\"on htmx:responseError[detail.xhr.status == 410] window.location.reload()\"&gt;\n...\n&lt;/body&gt;\n</code></pre>"},{"location":"example_project/","title":"Example project","text":"<p>While the fully fledged documentation is not ready and the project is in flux, it's better to use the \"example\" project as the reference.</p> <p>Run it locally and play with it to get a better understanding of how the library works.</p> <pre><code>poetry install\ncd example\ncp env.example .env\npoetry run python manage.py migrate\npoetry run python manage.py runserver\n</code></pre> <p>See example.</p>"},{"location":"management_commands/","title":"Management commands","text":""},{"location":"management_commands/#management-commands","title":"Management Commands","text":""},{"location":"management_commands/#createlivecomponent","title":"<code>createlivecomponent</code>","text":""},{"location":"management_commands/#description","title":"Description","text":"<p>The <code>createlivecomponent</code> command is used to quickly create a new livecomponent. This command generates the necessary Python and HTML files for the component.</p>"},{"location":"management_commands/#arguments","title":"Arguments","text":""},{"location":"management_commands/#positional-arguments","title":"Positional Arguments","text":"<ul> <li><code>app_name</code> (str): The name of the app. E.g., 'counters'.</li> <li><code>component_name</code> (str): Component name in snake case. The name can use directory separator for creating namespaces. Normally, the first namespace is the app name. E.g., 'counters/click_counter'.</li> </ul>"},{"location":"management_commands/#optional-arguments","title":"Optional Arguments","text":"<ul> <li><code>--class-name</code> (str): Optional class name for the component. E.g., 'ClickCounter'. If not given, the component name, converted to PascalCase, is used.</li> <li><code>-f</code>, <code>--force</code> (bool): Overwrite existing files. Default is <code>False</code>.</li> <li><code>--stateless</code> (bool): Create a stateless component. Default is <code>False</code>.</li> <li><code>--minimal</code> (bool): Create a minimal component without any commands. Default is <code>False</code>.</li> <li><code>--base-class</code> (str): Base class for the component. If not given, value from settings is used.</li> </ul>"},{"location":"management_commands/#usage-examples","title":"Usage Examples","text":""},{"location":"management_commands/#basic-usage","title":"Basic Usage","text":"<pre><code>python manage.py createlivecomponent counters counters/click_counter\n</code></pre> <p>This command will create the files:</p> <ul> <li><code>counters/components/counters/click_counter/click_counter.py</code> (Python file with the component class)</li> <li><code>counters/components/counters/click_counter/click_counter.html</code> (HTML template for the component)</li> </ul>"},{"location":"management_commands/#create-minimal-statless-component","title":"Create Minimal Statless Component","text":"<pre><code>python manage.py createlivecomponent counters counters/click_counter --stateless --minimal\n</code></pre>"},{"location":"management_commands/#settings-options","title":"Settings Options","text":""},{"location":"management_commands/#base-class-name","title":"Base Class Name","text":"<p>The base class name for the component can be configured in the Django settings under the <code>LIVECOMPONENTS</code> configuration. Example:</p> <pre><code># myproject/utils.py\nimport abc\nfrom typing import Generic\nfrom livecomponents import LiveComponent, StatelessLiveComponent\nfrom livecomponents.types import State\n\n\nclass MyLiveComponent(LiveComponent, abc.ABC, Generic[State]):\n    class Media:\n        js = [\"myproject/livecomponent.js\"]\n\n\nclass MyStatelessLiveComponent(StatelessLiveComponent):\n    class Media:\n        js = [\"myproject/livecomponent.js\"]\n</code></pre> <pre><code># settings.py\nLIVECOMPONENTS = {\n    # ...\n    # Settings for the \"./manage.py createlivecomponent\" command.\n    \"createlivecomponent\": {\n        \"base_class\": \"myproject.utils.MyLiveComponent\",\n        \"stateless_base_class\": \"myproject.utils.MyStatelessLiveComponent\",\n    },\n}\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Here's how you integrate live components after you've installed the package:</p> <ul> <li>Modify Django settings.</li> <li>Modify base HTML template.</li> <li>Modify URLs to include live components.</li> </ul>"},{"location":"quickstart/#django-settings","title":"Django settings","text":"<p>Add to installed apps following packages:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    \"django_components\",\n    \"django_components.safer_staticfiles\",\n    \"django_htmx\",\n    \"livecomponents\",\n    # ...\n]\n</code></pre> <p>Add HTMX middleware:</p> <pre><code>MIDDLEWARE = [\n    # ...\n    \"django_htmx.middleware.HtmxMiddleware\",\n    # ...\n]\n</code></pre> <p>Add component dirs for to static files:</p> <pre><code># Static files (CSS, JavaScript, Images)\nSTATICFILES_DIRS = [\n    # To load django-components specific to myapp\n    BASE_DIR / \"app_one/components\",\n    BASE_DIR / \"app_two/components\",\n]\n</code></pre> <p>You can also configure live components with the <code>LIVECOMPONENTS</code> settings dictionary. See the \"Configuration\" section for more details.</p>"},{"location":"quickstart/#base-template","title":"Base template","text":"<p>There, we need support for HTMX and Live Components:</p> <pre><code>{% load ... component_tags django_htmx livecomponents %}\n&lt;head&gt;\n  &lt;!-- Configure HTMX --&gt;\n  &lt;meta name=\"htmx-config\" content='{\"defaultSwapStyle\":\"none\"}'&gt;\n\n  &lt;!-- JavaScript dependencies --&gt;\n  &lt;script src=\"https://unpkg.com/htmx.org@1.9.6\"&gt;&lt;/script&gt;\n  &lt;script src=\"https://unpkg.com/htmx.org@1.9.6/dist/ext/json-enc.js\"&gt;&lt;/script&gt;\n\n  &lt;!-- Use this for idiomorph --&gt;\n  &lt;script src=\"https://unpkg.com/idiomorph/dist/idiomorph-ext.min.js\"&gt;&lt;/script&gt;\n  &lt;!-- Or this for Alpine morph --&gt;\n  &lt;script src=\"https://unpkg.com/htmx.org@1.9.6/dist/ext/alpine-morph.js\"&gt;&lt;/script&gt;\n  {% django_htmx_script %}\n\n  {% component_css_dependencies %}\n  {% livecomponents_session_id as LIVECOMPONENTS_SESSION_ID %}\n\n  &lt;script&gt;\n    // Optionally, clear the session on page unload.\n    //\n    // Firefox does not support keepalive fetches, so we need to use a workaround.\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon\n    // and https://bugzilla.mozilla.org/show_bug.cgi?id=1342484\n    const fetchUrl = \"{% url 'livecomponents:clear-session' %}?session_id={{ LIVECOMPONENTS_SESSION_ID }}\";\n    const csrfmiddlewaretoken = \"{{ csrf_token }}\";\n    window.addEventListener(\"beforeunload\", function () {\n        navigator.sendBeacon(fetchUrl, new URLSearchParams({csrfmiddlewaretoken}))\n    });\n\n    // Alternatively, use a regular fetch if you don't care about the issue above.\n    // window.addEventListener(\"beforeunload\", function () {\n    //   fetch(fetchUrl, {\n    //     keepalive: true,\n    //     method: \"POST\",\n    //     headers: {\"X-CSRFToken\": csrfmiddlewaretoken}\n    //   });\n    // });\n  &lt;/script&gt;\n  ...\n&lt;/head&gt;\n&lt;body hx-ext=\"morph, json-enc\" hx-headers='{\"X-CSRFToken\": \"{{ csrf_token }}\"}'&gt;\n&lt;!-- use hx-ext=\"alpine-morph, json-enc\" for Alpine.js morpher --&gt;\n...\n{% component_js_dependencies %}\n&lt;/body&gt;\n&lt;html&gt;\n</code></pre>"},{"location":"quickstart/#urls","title":"URLs","text":"<pre><code>from django.urls import path, include\n\nurlpatterns = [\n    # ...\n    path(\"livecomponents/\", include(\"livecomponents.urls\")),\n    # ...\n]\n</code></pre>"},{"location":"quickstart/#create-new-component","title":"Create new component","text":"<p>There is a management command to create new component:</p> <pre><code>./manage.py createlivecomponent &lt;app_name&gt; &lt;directory/component_name&gt;\n</code></pre> <p>The command with create a \"components\" subdirectory in the app directory and create a new component, consisting of one Python, and one HTML file.</p> <p>Make sure that your STATICFILES_DIRS setting includes the \"components\" directory of the app.</p> <p>Optionally, you can pass a <code>--stateless</code> flag to create a stateless component.</p>"},{"location":"templates/","title":"On Storing Raw HTML Templates","text":"<p>In Django-components, the same component can be represented as a flat node <code>{% component \"name\" key=value %}</code> or as a block node to populate slots:</p> <pre><code>{% component_block \"name\" key=value %}\n  {% fill \"slot_name\" %}\n    {{ variable_from_outer_context }}\n  {% endfill %}\n{% endcomponent_block %}\n</code></pre> <p>Rendering components with slots is non-trivial for two reasons:</p> <ul> <li>We need to store the Django HTML content of the slot.</li> <li>It should be possible to re-render the component in isolation without accessing the outer context.</li> </ul> <p>By the time the component is rendered with the <code>@register.tag()</code> function, we don't have access to the raw template content, only to tokens (generated from the raw template by Lexer) and to nodes (generated from the tokens by Parser).</p>"},{"location":"templates/#how-do-we-store-templates","title":"How Do We Store Templates","text":"<p>We introduce new flat tags \"livecomponent\" and block tags \"livecomponent_block\". While building the node (LiveComponentNode instead of ComponentNode of django-components), store the raw template content in the node. When the node is rendered, we associate the raw template content with the component ID to reuse it on re-render.</p>"},{"location":"templates/#more-on-storing-templates","title":"More on Storing Templates","text":"<p>It would be wasteful to store the entire HTML template for every component, considering that most components are rendered by the same template. To optimize space, we hash the template content and use it as the cache key:</p> <pre><code>127.0.0.1:6379&gt; get template_cache:LkAl5ah3\n\"{% livecomponent \\\"search\\\" parent_id=component_id search=search %}\"\n</code></pre> <p>Then, we have a separate Redis HASH \"templates:\" to map from component IDs to template hashes: <pre><code>127.0.0.1:6379&gt; hgetall templates:a99377ffe6a946e496542ac2c8a8cb96\n 1) \"/table.0\"\n 2) \"rPOwF_re\"\n 3) \"/table.0/search.0\"\n 4) \"LkAl5ah3\"\n ...\n</code></pre>"},{"location":"templates/#how-do-we-store-the-outer-context","title":"How Do We Store the Outer Context","text":"<p>However, we need to store the outer context, or rather, the variables from the outer context that are necessary to re-render the template.</p> <p>Here, there's not much we can do: we don't want to store the entire context in Redis because it's wasteful, hard to implement (not everything can be pickled), and can easily go out of sync.</p> <p>Instead, we offload this work to the component developer. The <code>init_state()</code> method for constructing the component state is called on the first render. There, a context variable has an \"outer_context\" attribute. The component developer can store any variables from the outer context in the state and then use them to re-render the component. As long as the developer uses the same name for the variable, the component will be re-rendered correctly.Here's an example:</p> <pre><code>class SampleState(BaseModel):\n    var: str = \"unset\"\n    ...\n\nclass Sample(LiveComponent):\n    ...\n\n    def init_state(self, context: InitStateContext) -&gt; SampleState:\n        var = context.outer_context.get(\"var\", \"unset\")\n        effective_kwargs = {**context.component_kwargs, \"var\": var}\n        return SampleState(**effective_kwargs)\n</code></pre>"},{"location":"templatetags/","title":"Templatetags","text":"<p>All templatetags are loaded with the \"livecomponents\" tag library:</p> <pre><code>{% load livecomponents %}\n</code></pre>"},{"location":"templatetags/#component_attrs","title":"component_attrs","text":"<p>Set \"data-livecomponent-id\" and \"hx-swap-oob\" attributes for the root tag of the component. It is expected to be used in every component template.</p> <p>Usage example:</p> <pre><code>&lt;div {% component_attrs component_id %}&gt;\n  &lt;!-- The actual component content --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"templatetags/#call_command","title":"call_command","text":"<p>Return the URL for calling a command on a component. The <code>component_id</code> argument is the component ID that is available in the render context. The <code>command_name</code> argument is the name of the command to call.</p> <p>Usage example:</p> <pre><code>&lt;button hx-post='{% call_command component_id \"my_command\" %}'&gt;Click me&lt;/button&gt;\n</code></pre> <p>Another example: passing arguments to the command</p> <p>Arguments are passed as JSON-encoded object in the <code>hx-vals</code> attribute.</p> <pre><code>&lt;button hx-post='{% call_command component_id \"my_command\" %}' hx-vals='{\"param\":\"value\"}'&gt;Click me&lt;/button&gt;\n</code></pre>"},{"location":"templatetags/#component_id","title":"component_id","text":"<p>Construct the component ID, built from type and ID pairs, following one after another.</p> <p>For example:</p> <pre><code>{% component_id \"table\" \"primary\" \"row\" 1 \"cell\" \"x\" as cell_x %}\n</code></pre> <p>will return</p> <pre><code>|table:primary|row:1|cell:x\n</code></pre>"},{"location":"templatetags/#component_ancestor","title":"component_ancestor","text":"<p>Return the ID of the closest ancestor component of the given type.</p> <p>For example, if the current component is <code>|table:primary|row:1|cell:x</code>, then</p> <pre><code>{% component_ancestor component_id \"table\" %}\n</code></pre> <p>Will return \"|table:primary\".</p> <p>Usage example:</p> <p>This is useful if the component state is stored in the root component, and managed by it. Below is a contrived example of how you can delete a specific row from the table, assuming that the table state is stored in the root component, and the current component (a row) keeps its ID in the \"row_id\" variable.</p> <pre><code>{% component_ancestor component_id \"table\" as table_id %}\n&lt;button hx-post='{% call_command table_id \"delete_row\" %}' hx-vals='{\"row_id\": {{ row_id }}}'&gt;Delete row&lt;/button&gt;\n</code></pre>"},{"location":"templatetags/#component_selector","title":"component_selector","text":"<p>Return the CSS selector for the component with the given ID.</p> <p>Can be used to select the component in JavaScript code. For example:</p> <pre><code>const element = document.querySelector({% component_selector component_id %});\n</code></pre> <p>Note that the returned value is already quoted, so you don't need to add quotes around it.</p>"},{"location":"templatetags/#no_morph","title":"no_morph","text":"<p>Return a key that disables morphing for the component.</p> <p>Random key is generated to prevent morphing of the component. See https://alpinejs.dev/plugins/morph#keys for more details.</p> <p>Usage example:</p> <pre><code>&lt;textarea {% no_morph %}&gt;&lt;/textarea&gt;\n</code></pre> <p>This way, the textarea DOM element will always be replaced, not morphed, which, for example, results in updating the component state from the server side.</p>"},{"location":"uploads/","title":"Handling Uploads","text":"<p>By default, the command handler accepts JSON-encoded data passed in the POST request. The HTMX extension <code>json-ext</code>, which we include in the base template, is responsible for this behavior. However, JSON-encoded data cannot include files, so we need to use the <code>multipart/form-data</code> encoding for this purpose.</p> <p>To process the files, create a file upload form in the HTML template of the component. Disable <code>json-ext</code> and explicitly set up the <code>multipart/form-data</code> encoding for the uploaded data. Then, include one or more file upload elements in the form.</p> <p>In the Python handler, uploaded files are available in the <code>call_context.request.FILES</code> variable. The rest of the form goes to the command kwargs, as usual.</p> <p>Here's an example of how the sample file upload form can look. Notice the <code>hx-ext=\"ignore:json-enc\"</code> attribute that disables the <code>json-ext</code> extension for this form.</p> <pre><code>  &lt;form hx-ext=\"ignore:json-enc\" hx-encoding='multipart/form-data' hx-post=\"{% call_command component_id \"upload_file\" %}\"&gt;\n      &lt;input type=\"file\" name=\"csv_file\" placeholder=\"CSV file\" required&gt;\n      &lt;button type=\"submit\"&gt;Upload CSV file&lt;/button&gt;\n  &lt;/form&gt;\n</code></pre> <p>Here's an example of how the handler can look:</p> <pre><code>    ...\n\n    @command\n    def upload_file(self, call_context: CallContext):\n        csv_file = call_context.request.FILES[\"csv_file\"]\n        ...\n</code></pre> <p>You can see a full example in the uploads app of the sample project.</p>"}]}